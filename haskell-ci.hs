#!/usr/bin/env stack
-- stack --resolver lts-10.4 script --package foundation --package directory --package cryptonite
{-# LANGUAGE OverloadedStrings #-}

import           Data.Char
import           Data.List
import           Data.Either
import           Data.Function (on)
import           Control.Monad (when)
import           System.Directory
import           System.Environment
import           System.Exit
import           System.IO
import           Crypto.Hash (hashWith, SHA256(..))
import           Config
import           Build
import qualified Yaml as Y
import qualified Foundation    as F
import qualified Foundation.IO as F

-- resolve all options in a build
resolveBuild :: C -> Build -> Build
resolveBuild c (Build x simples kvs) =
    -- a simple option could map to something else
    let mapped = map (\s -> case lookup s (options c) of
                                    Nothing -> ([s], [])
                                    Just p  -> p) simples
     in Build x (concatMap fst mapped) (kvs ++ concatMap snd mapped)

toTravis :: String -> C -> String
toTravis hash c = unlines $
    [ "# ~*~ auto-generated by haskell-ci with config : " ++ hash ++ " ~*~"
    , ""
    , "# Use new container infrastructure to enable caching"
    , "sudo: false"
    , ""
    , "# Caching so the next build will be fast too."
    , "cache:"
    , "  directories:"
    , "  - $HOME/.ghc"
    , "  - $HOME/.stack"
    , "  - $HOME/.local"
    , ""
    , "matrix:"
    , "  include:"
    ] ++ envs ++
    [ "  allow_failures:"
    ] ++ failureEnvs ++
    [ ""
    , "install:"
    , "  - export PATH=$HOME/.local/bin::$HOME/.cabal/bin:$PATH"
    , "  - mkdir -p ~/.local/bin"
    , "  - |"
    , "    case \"$BUILD\" in"
    , "      stack|weeder)"
    , "        if [ `uname` = \"Darwin\" ]"
    , "        then"
    , "          travis_retry curl --insecure -L https://www.stackage.org/stack/osx-x86_64 | tar xz --strip-components=1 --include '*/stack' -C ~/.local/bin"
    , "        else"
    , "          travis_retry curl -L https://www.stackage.org/stack/linux-x86_64 | tar xz --wildcards --strip-components=1 -C ~/.local/bin '*/stack'"
    , "        fi"
    , "      ;;"
    , "    cabal)"
    , "      ;;"
    , "    esac"
    , ""
    , "script:"
    , "- |"
    , "  set -ex"
    , "  if [ \"x${RUNTEST}\" = \"xfalse\" ]; then exit 0; fi"
    , "  case \"$BUILD\" in"
    , "    stack)"
    , "      # create the build stack.yaml"
    , "      case \"$RESOLVER\" in"
    ] ++ scriptResolverCase ++
    [ "      esac"
    -- , "      rm stack.yaml && ln -sv .travis/stack-${RESOLVER}.yaml stack.yaml"
    , "      # build & run test"
    , "      stack --no-terminal test --install-ghc --coverage --bench --no-run-benchmarks \\"
    , "          ${HADDOCK_OPTS}"
    , "      ;;"
    , "    hlint)"
    , "      curl -sL https://raw.github.com/ndmitchell/hlint/master/misc/travis.sh | sh -s . --cpp-define=__GLASGOW_HASKELL__=800 --cpp-define=x86_64_HOST_ARCH=1 --cpp-define=mingw32_HOST_OS=1"
    , "      ;;"
    , "    weeder)"
    , "      stack --no-terminal build --install-ghc"
    , "      curl -sL https://raw.github.com/ndmitchell/weeder/master/misc/travis.sh | sh -s ."
    , "      ;;"
    , "  esac"
    , "  set +ex"
    ]
  where
    -- resolved build
    bs = map (resolveBuild c) $ builds c

    optionalBuilds =
        [ BuildHLint, BuildWeeder ]

    scriptResolverCase = concatMap matchLines $ map unbuild $ bs
      where
        unbuild (Build compiler simple kvs) =
            let resolver = compilerToLts c compiler
                flags = map toPkgFlag $ groupBy ((==)  `on` fst) $ map parseFlag $ getFlags kvs
                extraPkgs = map snd $ filter ((==) "package" . fst) kvs
                extraDeps = map snd $ filter ((==) "extradep" . fst) kvs
                noHaddock = elem "nohaddock" simple
             in (compiler, resolver, packages c ++ extraPkgs, extraDeps, flags, not noHaddock)

          where getFlags = map snd . filter ((==) "flag" . fst)
                parseFlag x = case splitChar ':' x of
                                    Nothing -> error ("cannot parse flag " ++ x ++ " should be of the form \"packagename:(-)flagname\"")
                                    Just (p,f) | isPrefixOf "-" f -> (p, (f, False))
                                               | otherwise        -> (p, (f, True))
                toPkgFlag l = PackageFlag (head $ map fst l) (map snd l)

        matchLines (compiler, resolver, packages, extraDeps, flags, useHaddock) =
            [ "      " ++ compiler ++ ")"
            , "        echo \"" ++ stackYaml resolver packages extraDeps flags ++ "\" > stack.yaml"
            , "        export HADDOCK_OPTs=\"" ++ haddockOpt ++ "\""
            , "        ;;"
            ]
         where haddockOpt | useHaddock = "--haddock --no-haddock-deps"
                          | otherwise  = "--no-haddock"

    stackYaml :: String -> [String] -> [String] -> [PackageFlag] -> String
    stackYaml resolver packages extraDeps flags = Y.toString $ Y.dict
        [ (Y.key "resolver", Y.string resolver)
        , (Y.key "packages", Y.list $ map Y.string packages)
        , (Y.key "extra-deps", Y.list $ map Y.string extraDeps)
        , (Y.key "flags", Y.dict (map toPkgFlag flags))
        ]
      where
        toPkgFlag (PackageFlag pkg flags) =
            (Y.key pkg, Y.dict $ map (\(flagName, enabled) -> (Y.key flagName, Y.string $ if enabled then "true" else "false")) flags )

    envs = concatMap env (map toBuildTypes bs ++ optionalBuilds)
    failureEnvs = concatMap env (map toBuildTypes (filter isAllowedFailure bs) ++ optionalBuilds)
      where isAllowedFailure (Build _ simples _) = "allowed-failure" `elem` simples

    toBuildTypes (Build r simples kvs) =
        BuildStack r (maybe Linux (\os -> if os == "osx" then OsX else Linux) $ lookup "os" kvs)

    env BuildHLint =
        [ (++) "  - " $ Y.toString $ Y.dict
            [ (Y.key "env", Y.string "BUILD=hlint"), (Y.key "compiler", Y.string "hlint"), language ] ]
    env BuildWeeder =
        [ (++) "  - " $ Y.toString $ Y.dict
            [ (Y.key "env", Y.string "BUILD=weeder"), (Y.key "compiler", Y.string "weeder"), language, addOn ] ]
    env (BuildStack compiler ostype) =
        [ (++) "  - " $ Y.toString $ Y.dict $
            [ (Y.key "env", Y.string ("BUILD=stack RESOLVER=" ++ compiler))
            , (Y.key "compiler", Y.string compiler), language, addOn
            ] ++ (if ostype == OsX then [ (Y.key "os", Y.string "osx") ] else [])
        ]
    addOn = (Y.key "addons", Y.dict [ (Y.key "apt", Y.dict [ (Y.key "packages", Y.list [ Y.string "libgmp-dev" ]) ] ) ])
    language = (Y.key "language", Y.string "generic")

escapeQuote :: String -> String
escapeQuote [] = []
escapeQuote (x:xs)
    | x == '='  = '\\' : '"' : escapeQuote xs
    | otherwise = x : escapeQuote xs

main = do
    let hci = ".haskell-ci"
        -- read and parse .haskell-ci
        readHci = do
            y <- doesFileExist hci
            when (not y) $ do
                hPutStrLn stderr
                exitFailure
            parse <$> readFile hci

    a <- getArgs
    case a of
        ["generate"] -> do
            already <- doesFileExist hci
            when already $ do
                hPutStrLn stderr ("error: this directory already contains a " ++ hci ++ " file")
                exitFailure
            writeFile hci $ unlines
                [ "# compiler supported and their equivalent LTS"
                , "compiler: ghc-7.8 lts-2.22"
                , "compiler: ghc-7.10 lts-6.35"
                , "compiler: ghc-8.0 lts-9.21"
                , "compiler: ghc-8.2 lts-10.4"
                , ""
                , "# options"
                , "# option: alias x=y z=v"
                , ""
                , "# builds "
                , "build: ghc-7.8 nohaddock"
                , "build: ghc-8.2"
                , "build: ghc-7.10"
                , "build: ghc-8.0"
                , "build: ghc-8.0 os=osx"
                , ""
                , "# packages"
                , "package: '.'"
                , ""
                , "# extra builds"
                , "hlint: allowed-failure"
                , "weeder: allowed-failure"
                , "coverall: false"
                ]
        ["travis"]      -> do
            cfg <- readHci
            h   <- show . hashWith SHA256 <$> F.readFile ".haskell-ci"
            putStrLn $ toTravis h cfg
            return ()
        -- ["local-build"] -> do -- try to run all builds locally with every resolver capable on this system
        --    cfg <- readHci
        --    let builds = map (resolveBuilds cfg) $ builds cfg
        _            -> do
            hPutStrLn stderr "usage: haskell-ci [generate|travis]"
            exitFailure
