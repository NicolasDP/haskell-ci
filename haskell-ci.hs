#!/usr/bin/env stack
-- stack --resolver lts-10.4 script --package foundation --package directory --package cryptonite
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DataKinds #-}

import           Data.Char
import           Data.List
import           Data.Either
import           Data.Function (on)
import           Control.Monad (when)
import           System.Directory
import           System.Environment
import           System.Exit
import           System.IO
import           Crypto.Hash (hashWith, SHA256(..), Digest)
import           Config
import           Build
import qualified Yaml as Y
import qualified Foundation    as F
import qualified Foundation.IO as F

-- resolve all options in a build
resolveBuild :: C -> BuildEnv 'Unresolved -> BuildEnv 'Resolved
resolveBuild c (BuildEnv x simples kvs) =
    -- a simple option could map to something else
    let mapped = map (\s -> case lookup s (options c) of
                                    Nothing -> ([s], [])
                                    Just p  -> p) simples
     in BuildEnv x (concatMap fst mapped) (kvs ++ concatMap snd mapped)

yamlAutoGeneratedComment :: Digest SHA256 -> String
yamlAutoGeneratedComment hash = "# ~*~ auto-generated by haskell-ci with config : " ++ show hash ++ " ~*~"

stackYaml :: Build -> String
stackYaml build = Y.toString $ Y.dict
    [ (Y.key "resolver", Y.string (buildResolver build))
    , (Y.key "packages", Y.list $ map Y.string (buildPackages build))
    , (Y.key "extra-deps", Y.list $ map Y.string (buildExtraDeps build))
    , (Y.key "flags", Y.dict (map toPkgFlag $ buildFlags build))
    ]
  where
    toPkgFlag (PackageFlag pkg flags) =
        (Y.key pkg, Y.dict $ map (\(flagName, enabled) -> (Y.key flagName, Y.string $ if enabled then "true" else "false")) flags )

makeBuildFromEnv :: C -> BuildEnv 'Resolved -> Build
makeBuildFromEnv c (BuildEnv compiler simple kvs) =
    let resolver = compilerToLts c compiler
        flags = map toPkgFlag $ groupBy ((==)  `on` fst) $ map parseFlag $ getFlags kvs
        extraPkgs = map snd $ filter ((==) "package" . fst) kvs
        extraDeps = map snd $ filter ((==) "extradep" . fst) kvs
        noHaddock = elem "nohaddock" simple
     in Build { buildName        = compiler
              , buildResolver    = resolver
              , buildFlags       = flags
              , buildPackages    = packages c ++ extraPkgs
              , buildExtraDeps   = extraDeps
              , buildUseHaddock  = not noHaddock
              }
  where getFlags = map snd . filter ((==) "flag" . fst)
        parseFlag x = case splitChar ':' x of
                            Nothing -> error ("cannot parse flag " ++ x ++ " should be of the form \"packagename:(-)flagname\"")
                            Just (p,f) | isPrefixOf "-" f -> (p, (f, False))
                                       | otherwise        -> (p, (f, True))
        toPkgFlag l = PackageFlag (head $ map fst l) (map snd l)

toTravis :: Digest SHA256 -> C -> String
toTravis hash c = unlines $
    [ yamlAutoGeneratedComment hash
    , ""
    , "# Use new container infrastructure to enable caching"
    , "sudo: false"
    , ""
    , "# Caching so the next build will be fast too."
    , "cache:"
    , "  directories:"
    , "  - $HOME/.ghc"
    , "  - $HOME/.stack"
    , "  - $HOME/.local"
    , ""
    , "matrix:"
    , "  include:"
    ] ++ envs ++
    [ "  allow_failures:"
    ] ++ failureEnvs ++
    [ ""
    , "install:"
    , "  - export PATH=$HOME/.local/bin::$HOME/.cabal/bin:$PATH"
    , "  - mkdir -p ~/.local/bin"
    , "  - |"
    , "    case \"$BUILD\" in"
    , "      stack|weeder)"
    , "        if [ `uname` = \"Darwin\" ]"
    , "        then"
    , "          travis_retry curl --insecure -L https://www.stackage.org/stack/osx-x86_64 | tar xz --strip-components=1 --include '*/stack' -C ~/.local/bin"
    , "        else"
    , "          travis_retry curl -L https://www.stackage.org/stack/linux-x86_64 | tar xz --wildcards --strip-components=1 -C ~/.local/bin '*/stack'"
    , "        fi"
    , "      ;;"
    , "    cabal)"
    , "      ;;"
    , "    esac"
    , ""
    , "script:"
    , "- |"
    , "  set -ex"
    , "  if [ \"x${RUNTEST}\" = \"xfalse\" ]; then exit 0; fi"
    , "  case \"$BUILD\" in"
    , "    stack)"
    , "      # create the build stack.yaml"
    , "      case \"$RESOLVER\" in"
    ] ++ scriptResolverCase ++
    [ "      esac"
    , "      # build & run test"
    , "      stack --no-terminal test --install-ghc --coverage --bench --no-run-benchmarks ${HADDOCK_OPTS}"
    , "      ;;"
    , "    hlint)"
    , "      curl -sL https://raw.github.com/ndmitchell/hlint/master/misc/travis.sh | sh -s . --cpp-define=__GLASGOW_HASKELL__=800 --cpp-define=x86_64_HOST_ARCH=1 --cpp-define=mingw32_HOST_OS=1"
    , "      ;;"
    , "    weeder)"
    , "      stack --no-terminal build --install-ghc"
    , "      curl -sL https://raw.github.com/ndmitchell/weeder/master/misc/travis.sh | sh -s ."
    , "      ;;"
    , "  esac"
    , "  set +ex"
    ]
  where
    -- resolved build
    bs = map (resolveBuild c) $ builds c

    optionalBuilds =
        [ BuildHLint, BuildWeeder ]

    scriptResolverCase = concatMap matchLines $ map (makeBuildFromEnv c) $ bs
      where
        matchLines build =
            [ "      " ++ buildName build ++ ")"
            , "        echo \"" ++ stackYaml build ++ "\" > stack.yaml"
            , "        export HADDOCK_OPTs=\"" ++ haddockOpt ++ "\""
            , "        ;;"
            ]
         where haddockOpt | buildUseHaddock build = "--haddock --no-haddock-deps"
                          | otherwise             = "--no-haddock"

    envs = concatMap env (map toBuildTypes bs ++ optionalBuilds)
    failureEnvs = concatMap env (map toBuildTypes (filter isAllowedFailure bs) ++ optionalBuilds)
      where isAllowedFailure (BuildEnv _ simples _) = "allowed-failure" `elem` simples

    toBuildTypes (BuildEnv r simples kvs) =
        BuildStack r (maybe Linux (\os -> if os == "osx" then OsX else Linux) $ lookup "os" kvs)

    env BuildHLint =
        [ (++) "  - " $ Y.toString $ Y.dict
            [ (Y.key "env", Y.string "BUILD=hlint"), (Y.key "compiler", Y.string "hlint"), language ] ]
    env BuildWeeder =
        [ (++) "  - " $ Y.toString $ Y.dict
            [ (Y.key "env", Y.string "BUILD=weeder"), (Y.key "compiler", Y.string "weeder"), language, addOn ] ]
    env (BuildStack compiler ostype) =
        [ (++) "  - " $ Y.toString $ Y.dict $
            [ (Y.key "env", Y.string ("BUILD=stack RESOLVER=" ++ compiler))
            , (Y.key "compiler", Y.string compiler), language, addOn
            ] ++ (if ostype == OsX then [ (Y.key "os", Y.string "osx") ] else [])
        ]
    addOn = (Y.key "addons", Y.dict [ (Y.key "apt", Y.dict [ (Y.key "packages", Y.list [ Y.string "libgmp-dev" ]) ] ) ])
    language = (Y.key "language", Y.string "generic")

escapeQuote :: String -> String
escapeQuote [] = []
escapeQuote (x:xs)
    | x == '='  = '\\' : '"' : escapeQuote xs
    | otherwise = x : escapeQuote xs

quitWith m = hPutStrLn stderr ("error: " ++ m) >> exitFailure

main = do
    let hci = ".haskell-ci"
        -- read and parse .haskell-ci
        readHci = do
            y <- doesFileExist hci
            when (not y) $ quitWith "no .haskell-ci file found"
            parse <$> readFile hci
        readHciHash = hashWith SHA256 <$> F.readFile ".haskell-ci"

    a <- getArgs
    case a of
        ["generate"] -> do
            already <- doesFileExist hci
            when already $ quitWith ("this directory already contains a " ++ hci ++ " file")
            writeFile hci $ unlines
                [ "# compiler supported and their equivalent LTS"
                , "compiler: ghc-7.8 lts-2.22"
                , "compiler: ghc-7.10 lts-6.35"
                , "compiler: ghc-8.0 lts-9.21"
                , "compiler: ghc-8.2 lts-10.4"
                , ""
                , "# options"
                , "# option: alias x=y z=v"
                , ""
                , "# builds "
                , "build: ghc-7.8 nohaddock"
                , "build: ghc-8.2"
                , "build: ghc-7.10"
                , "build: ghc-8.0"
                , "build: ghc-8.0 os=osx"
                , ""
                , "# packages"
                , "package: '.'"
                , ""
                , "# extra builds"
                , "hlint: allowed-failure"
                , "weeder: allowed-failure"
                , "coverall: false"
                ]
        ["travis"]      -> do
            cfg <- readHci
            h   <- readHciHash
            putStrLn $ toTravis h cfg
            return ()
        ("stack":name:[]) -> do
            cfg <- readHci
            h   <- readHciHash
            case find (\(BuildEnv b _ _) -> b == name) (builds cfg) of
                Nothing   -> quitWith ("no build name called " ++ name ++ " found")
                Just benv -> do
                    let resolved = resolveBuild cfg benv
                        build    = makeBuildFromEnv cfg resolved
                        gen      = stackYaml build
                    putStrLn $ unlines [ yamlAutoGeneratedComment h, gen ]
        -- ["local-build"] -> do -- try to run all builds locally with every resolver capable on this system
        --    cfg <- readHci
        --    let builds = map (resolveBuilds cfg) $ builds cfg
        _            -> do
            hPutStrLn stderr "usage: haskell-ci [generate|travis|stack <name>]"
            exitFailure
